name: Dependency Review

on:
  pull_request:

permissions:
  contents: read
  pull-requests: read

jobs:
  capability:
    runs-on: ubuntu-latest
    outputs:
      run_dependency_review: ${{ steps.detect.outputs.run_dependency_review }}
    steps:
      - name: Detect dependency review capability
        id: detect
        uses: actions/github-script@v8
        env:
          SECURITY_ENABLED: ${{ vars.SECURITY_ENABLED }}
        with:
          script: |
            const securityEnabled = process.env.SECURITY_ENABLED === '1';
            if (!securityEnabled) {
              core.info(`SECURITY_ENABLED=${process.env.SECURITY_ENABLED || 'unset'} -> Dependency Review disabled by policy variable.`);
              core.setOutput('run_dependency_review', 'false');
              return;
            }

            let codeSecurityLikelyEnabled = false;
            let dependencyGraphEnabled = false;

            try {
              await github.request('GET /repos/{owner}/{repo}/code-scanning/default-setup', {
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              core.info('Code Security probe succeeded via code-scanning/default-setup.');
              codeSecurityLikelyEnabled = true;
            } catch (error) {
              const status = Number(error?.status || error?.response?.status || 0);
              const message = error?.response?.data?.message || error?.message || 'unknown error';
              const integrationLimited =
                status === 403 && /resource not accessible by integration/i.test(message);
              const featureDisabled =
                status === 403 && /code security must be enabled/i.test(message);

              if (integrationLimited) {
                core.info(`Code Security probe blocked by token scope (status=${status}); proceeding with dependency review.`);
                codeSecurityLikelyEnabled = true;
              } else if (featureDisabled) {
                core.info(`Code Security is disabled (status=${status}); skipping dependency review.`);
                codeSecurityLikelyEnabled = false;
              } else {
                core.info(`Code Security probe unavailable (status=${status || 'n/a'}): ${message}`);
                codeSecurityLikelyEnabled = false;
              }
            }

            try {
              await github.request('GET /repos/{owner}/{repo}/dependency-graph/sbom', {
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
              core.info('Dependency graph probe succeeded via dependency-graph/sbom.');
              dependencyGraphEnabled = true;
            } catch (error) {
              const status = Number(error?.status || error?.response?.status || 0);
              const message = error?.response?.data?.message || error?.message || 'unknown error';
              core.info(`Dependency graph probe unavailable (status=${status || 'n/a'}): ${message}`);
              dependencyGraphEnabled = false;
            }

            const runDependencyReview = codeSecurityLikelyEnabled && dependencyGraphEnabled;
            core.setOutput('run_dependency_review', runDependencyReview ? 'true' : 'false');

  review:
    needs: capability
    if: ${{ needs.capability.outputs.run_dependency_review == 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Dependency review
        uses: actions/dependency-review-action@v4
