name: Hotfix Backport

on:
  pull_request:
    types: [closed]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  backport:
    if: ${{ vars.BACKPORT_ENABLED == '1' && github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 1
          ref: ${{ github.event.pull_request.base.ref }}

      - name: Open backport PR (main -> dev) for hotfix merges
        uses: actions/github-script@v8
        with:
          script: |
            const path = require('path');

            const root = process.env.GITHUB_WORKSPACE || process.cwd();

            function startsWithAny(value, prefixes) {
              const v = String(value || '').trim();
              if (!v) return false;
              const list = Array.isArray(prefixes) ? prefixes : [];
              return list.some((p) => {
                const pref = String(p || '').trim();
                return pref ? v.startsWith(pref) : false;
              });
            }

            const pr = context.payload.pull_request;
            const baseRef = String(pr?.base?.ref || '').trim();
            const headRef = String(pr?.head?.ref || '').trim();
            const prBody = String(pr?.body || '');

            if (!pr?.base?.repo?.full_name || !pr?.head?.repo?.full_name || pr.base.repo.full_name !== pr.head.repo.full_name) {
              core.info('Skip: hotfix backport automation only supports PRs from branches within the same repository.');
              return;
            }

            let policyCfg;
            try {
              const { loadBranchPolicyConfig } = require('./scripts/ops/branch-policy');
              policyCfg = loadBranchPolicyConfig(root).config;
            } catch (e) {
              core.warning(`Unable to load scripts/ops/branch-policy.js; using minimal defaults. ${e.message}`);
              policyCfg = {
                integration_branch: 'dev',
                production_branch: 'main',
                hotfix_branch_prefixes: ['hotfix/'],
              };
            }

            const integration = String(policyCfg.integration_branch || '').trim() || 'dev';
            const production = String(policyCfg.production_branch || '').trim() || 'main';
            const hotfixPrefixes = Array.isArray(policyCfg.hotfix_branch_prefixes) ? policyCfg.hotfix_branch_prefixes : ['hotfix/'];

            const isHotfix = startsWithAny(headRef, hotfixPrefixes);
            if (baseRef !== production || !isHotfix) {
              core.info(`Skip: base=${baseRef}, head=${headRef} (expected hotfix merge into ${production})`);
              return;
            }

            // Ensure integration branch exists.
            try {
              await github.rest.repos.getBranch({ owner: context.repo.owner, repo: context.repo.repo, branch: integration });
            } catch (e) {
              core.warning(`Integration branch missing (${integration}); cannot create backport PR.`);
              return;
            }

            const prMetaPath = path.join(root, 'scripts', 'ops', 'plans', 'pr-meta.js');
            const { extractPlanIds, extractStep } = require(prMetaPath);
            const planIds = extractPlanIds(prBody || '');
            const step = extractStep(prBody || '');
            if (!planIds.length || !step) {
              core.setFailed(`Hotfix PR is missing Plan/Step metadata; cannot generate backport PR. (Plan ids=${planIds.join(',') || '<none>'}, step=${step || '<none>'})`);
              return;
            }

            // Skip when there's nothing to backport.
            try {
              const cmp = await github.rest.repos.compareCommits({
                owner: context.repo.owner,
                repo: context.repo.repo,
                base: integration,
                head: production,
              });
              const aheadBy = Number(cmp?.data?.ahead_by || 0);
              if (!aheadBy) {
                core.info(`Skip: ${integration} is already up to date with ${production}.`);
                return;
              }
            } catch (e) {
              core.warning(`Unable to compare ${integration}...${production}; proceeding. ${e.message}`);
            }

            // Avoid duplicates: if an open PR already exists from production -> integration, do nothing.
            const existing = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              base: integration,
              head: `${context.repo.owner}:${production}`,
              per_page: 10,
            });
            if ((existing?.data || []).length > 0) {
              core.info(`Backport PR already open: ${existing.data[0].html_url}`);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `Backport PR already open: ${existing.data[0].html_url}`,
              }).catch(() => {});
              return;
            }

            const title = `backport: ${headRef} -> ${integration}`;
            const body = [
              '## Plan',
              `Plan: ${planIds[0]}`,
              `Step: ${step}`,
              '',
              '## Summary',
              `- Automated backport PR after hotfix merge into \`${production}\`.`,
              '',
              '## References',
              `- Source PR: ${pr?.html_url || `#${pr?.number || ''}`}`,
              `- Hotfix branch: \`${headRef}\``,
              '',
              '## Verification',
              '- [ ] `npm test`',
              '',
            ].join('\n');

            const created = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              head: production,
              base: integration,
              body,
              maintainer_can_modify: true,
            });

            const url = created?.data?.html_url || '';
            core.info(`Created backport PR: ${url || '<unknown>'}`);

            if (url) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: `Backport PR created: ${url}`,
              }).catch(() => {});
            }
