name: Promote (Staging)

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref/sha to deploy (optional; defaults to integration branch HEAD)"
        required: false
        default: ""
      base_ref:
        description: "Optional base ref for surface auto-detection (compare base...ref). When omitted, uses the first parent of ref."
        required: false
        default: ""
      component:
        description: "Fallback single surface when registry is missing (safe token; default: application). Ignored when surfaces provided."
        required: false
        default: application
      surfaces:
        description: "Optional surfaces CSV override (e.g. application,docs)."
        required: false
        default: ""
      approval_mode:
        description: "Approval mode override (commit|surface). Optional: uses repo var default then registry default."
        required: false
        default: ""
  issue_comment:
    types: [created]

permissions:
  contents: read
  actions: write
  issues: read
  pull-requests: read

jobs:
  prepare:
    if: >-
      ${{
        github.event_name == 'workflow_dispatch'
        || (
          github.event_name == 'issue_comment'
          && startsWith(github.event.comment.body, '/approve-staging')
        )
      }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      workflow_ref: ${{ steps.req.outputs.workflow_ref }}
      deploy_ref: ${{ steps.req.outputs.deploy_ref }}
      issue_number: ${{ steps.req.outputs.issue_number }}
      surfaces_json: ${{ steps.surfaces.outputs.surfaces_json }}
      approval_mode: ${{ steps.approvals.outputs.approval_mode }}
      approval_env_commit: ${{ steps.approvals.outputs.approval_env_commit }}
      surface_approval_matrix_json: ${{ steps.approvals.outputs.surface_approval_matrix_json }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Resolve promotion request (auth + ref)
        id: req
        uses: actions/github-script@v8
        env:
          INPUT_REF: ${{ inputs.ref }}
          INPUT_BASE_REF: ${{ inputs.base_ref }}
          INPUT_COMPONENT: ${{ inputs.component }}
          INPUT_SURFACES: ${{ inputs.surfaces }}
          INPUT_APPROVAL_MODE: ${{ inputs.approval_mode }}
        with:
          script: |
            const fs = require('fs');

            function toString(v) {
              return String(v == null ? '' : v).trim();
            }

            function loadIntegrationBranch() {
              try {
                const cfg = JSON.parse(fs.readFileSync('config/policy/branch-policy.json', 'utf8'));
                return toString(cfg && cfg.integration_branch) || 'dev';
              } catch {
                return 'dev';
              }
            }

            async function hasMaintainerPermission(actor) {
              const res = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: actor,
              });
              const level = toString(res && res.data && res.data.permission).toLowerCase();
              return ['admin', 'maintain', 'write'].includes(level);
            }

            const actor = toString(context.actor);
            const integrationBranch = loadIntegrationBranch();
            const authorized = await hasMaintainerPermission(actor);
            if (!authorized) {
              core.setFailed(`Actor "${actor}" is not authorized to promote staging (requires write/maintain/admin).`);
              return;
            }

            let deployRef = '';
            let baseRef = '';
            let issueNumber = '';
            let surfacesOverride = '';
            let component = '';
            let approvalModeInput = '';

            if (context.eventName === 'issue_comment') {
              const issue = context.payload.issue || {};
              const isPrComment = !!issue.pull_request;
              if (!isPrComment) {
                core.setFailed('`/approve-staging` must be posted on a pull request.');
                return;
              }

              issueNumber = toString(issue.number);
              const body = toString(context.payload.comment && context.payload.comment.body);
              const parts = body.split(/\s+/g).filter(Boolean);
              // /approve-staging [surfacesCsv]
              surfacesOverride = toString(parts[1] || '');

              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: Number(issueNumber),
              });
              const baseRefName = toString(pr && pr.data && pr.data.base && pr.data.base.ref);
              if (baseRefName !== integrationBranch) {
                core.setFailed(`PR #${issueNumber} targets "${baseRefName}". Expected integration branch "${integrationBranch}".`);
                return;
              }
              if (!pr.data.merged) {
                core.setFailed(`PR #${issueNumber} is not merged. Merge it before running /approve-staging.`);
                return;
              }
              deployRef = toString(pr.data.merge_commit_sha) || toString(pr.data.head && pr.data.head.sha);
            } else {
              const inputRef = toString(process.env.INPUT_REF);
              const inputBaseRef = toString(process.env.INPUT_BASE_REF);
              surfacesOverride = toString(process.env.INPUT_SURFACES);
              component = toString(process.env.INPUT_COMPONENT);
              approvalModeInput = toString(process.env.INPUT_APPROVAL_MODE);

              const resolved = inputRef || integrationBranch;
              const commit = await github.rest.repos.getCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: resolved,
              });
              deployRef = toString(commit && commit.data && commit.data.sha) || resolved;

              if (inputBaseRef) {
                const baseCommit = await github.rest.repos.getCommit({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: inputBaseRef,
                });
                baseRef = toString(baseCommit && baseCommit.data && baseCommit.data.sha) || inputBaseRef;
              } else {
                const parents = Array.isArray(commit && commit.data && commit.data.parents) ? commit.data.parents : [];
                baseRef = toString(parents[0] && parents[0].sha) || '';
              }
            }

            core.setOutput('workflow_ref', integrationBranch);
            core.setOutput('deploy_ref', deployRef);
            core.setOutput('base_ref', baseRef);
            core.setOutput('issue_number', issueNumber);
            core.setOutput('surfaces_override', surfacesOverride);
            core.setOutput('component', component || 'application');
            core.setOutput('approval_mode_input', approvalModeInput);

      - name: Compare files (dispatch mode; used for surface auto-detection)
        id: compare
        if: ${{ steps.req.outputs.issue_number == '' && steps.req.outputs.surfaces_override == '' }}
        uses: actions/github-script@v8
        with:
          script: |
            function toString(v) {
              return String(v == null ? '' : v).trim();
            }
            const base = toString('${{ steps.req.outputs.base_ref }}');
            const head = toString('${{ steps.req.outputs.deploy_ref }}');
            if (!base || !head) {
              core.setOutput('files_json', '[]');
              core.info('Missing base/head; skipping compare');
              return;
            }
            const res = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base,
              head,
            });
            const files = Array.isArray(res && res.data && res.data.files) ? res.data.files : [];
            const names = files.map((f) => String(f && f.filename || '').trim()).filter(Boolean);
            core.setOutput('files_json', JSON.stringify(names));
            core.info(`compare files=${names.length} base=${base} head=${head}`);

      - name: Resolve affected surfaces
        id: surfaces
        shell: bash
        env:
          DEPLOY_SURFACES_PATH: ${{ vars.DEPLOY_SURFACES_PATH || 'config/deploy/deploy-surfaces.json' }}
          GITHUB_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ steps.req.outputs.issue_number }}
          SURFACES_OVERRIDE: ${{ steps.req.outputs.surfaces_override }}
          FALLBACK_COMPONENT: ${{ steps.req.outputs.component }}
          FILES_JSON: ${{ steps.compare.outputs.files_json }}
        run: |
          set -euo pipefail

          registry_exists=0
          if [ -f "${DEPLOY_SURFACES_PATH}" ]; then
            registry_exists=1
          fi

          if [ -n "${SURFACES_OVERRIDE}" ]; then
            surfaces_json="$(node -e "const { normalizeSurfaceId } = require('./scripts/ops/deploy-surface-registry'); const csv=process.env.SURFACES_OVERRIDE||''; const out=csv.split(',').map(s=>normalizeSurfaceId(s)).filter(Boolean); process.stdout.write(JSON.stringify(out));")"
          elif [ -n "${ISSUE_NUMBER}" ]; then
            surfaces_json="$(node scripts/ops/changed-surfaces.js --pr "${ISSUE_NUMBER}" --token "${GITHUB_TOKEN}" --registry "${DEPLOY_SURFACES_PATH}")"
          else
            if [ -z "${FILES_JSON}" ]; then
              echo "::error::Unable to auto-detect surfaces: missing FILES_JSON."
              exit 1
            fi
            surfaces_json="$(node scripts/ops/changed-surfaces.js --files-json "${FILES_JSON}" --registry "${DEPLOY_SURFACES_PATH}")"
          fi

          if [ "${surfaces_json}" = "[]" ]; then
            if [ "${registry_exists}" = "1" ]; then
              echo "::error::No surfaces matched for this promotion request. Update deploy-surfaces.json or provide a surfaces override."
              exit 1
            fi
            # Registry missing: fall back to a single component/surface.
            surfaces_json="$(node -e "const { normalizeComponent } = require('./scripts/ops/deploy-surface-registry'); const c=normalizeComponent(process.env.FALLBACK_COMPONENT||'application'); if (!c) process.exit(2); process.stdout.write(JSON.stringify([c]));")"
          fi

          if [ "${surfaces_json}" = "[]" ]; then
            echo "::error::No surfaces resolved."
            exit 1
          fi

          echo "surfaces_json=${surfaces_json}" >> "$GITHUB_OUTPUT"
          echo "Resolved surfaces: ${surfaces_json}"

      - name: Resolve approval mode + environment matrix
        id: approvals
        env:
          TIER: staging
          SURFACES_JSON: ${{ steps.surfaces.outputs.surfaces_json }}
          APPROVAL_MODE: ${{ steps.req.outputs.approval_mode_input }}
          REPO_VAR_APPROVAL_MODE: ${{ vars.STAGING_APPROVAL_MODE_DEFAULT }}
          DEPLOY_SURFACES_PATH: ${{ vars.DEPLOY_SURFACES_PATH || 'config/deploy/deploy-surfaces.json' }}
        run: |
          node scripts/ops/approval-matrix.js \
            --tier "${TIER}" \
            --surfaces-json "${SURFACES_JSON}" \
            --approval-mode "${APPROVAL_MODE}" \
            --repo-var-approval-mode "${REPO_VAR_APPROVAL_MODE}"

  approve_commit:
    needs: [prepare]
    if: ${{ needs.prepare.outputs.approval_mode == 'commit' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    environment: ${{ needs.prepare.outputs.approval_env_commit }}
    steps:
      - run: echo "Staging commit-level approval granted."

  approve_surface:
    needs: [prepare]
    if: ${{ needs.prepare.outputs.approval_mode == 'surface' }}
    runs-on: ubuntu-latest
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.prepare.outputs.surface_approval_matrix_json) }}
    environment: ${{ matrix.approval_env }}
    steps:
      - run: echo "Staging surface-level approval granted for ${{ matrix.surface }}"

  dispatch_commit:
    needs: [prepare, approve_commit]
    if: ${{ needs.prepare.outputs.approval_mode == 'commit' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        surface: ${{ fromJSON(needs.prepare.outputs.surfaces_json) }}
    steps:
      - name: Dispatch deployment workflow (staging)
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy.yml',
              ref: '${{ needs.prepare.outputs.workflow_ref }}',
              inputs: {
                environment: 'staging',
                ref: '${{ needs.prepare.outputs.deploy_ref }}',
                component: '${{ matrix.surface }}',
                promotion_source: 'approved-flow',
              },
            });
            core.info(`Staging deployment dispatched surface=${'${{ matrix.surface }}'} ref=${'${{ needs.prepare.outputs.deploy_ref }}'}`);

  dispatch_surface:
    needs: [prepare, approve_surface]
    if: ${{ needs.prepare.outputs.approval_mode == 'surface' }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    strategy:
      fail-fast: false
      matrix:
        surface: ${{ fromJSON(needs.prepare.outputs.surfaces_json) }}
    steps:
      - name: Dispatch deployment workflow (staging)
        uses: actions/github-script@v8
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy.yml',
              ref: '${{ needs.prepare.outputs.workflow_ref }}',
              inputs: {
                environment: 'staging',
                ref: '${{ needs.prepare.outputs.deploy_ref }}',
                component: '${{ matrix.surface }}',
                promotion_source: 'approved-flow',
              },
            });
            core.info(`Staging deployment dispatched surface=${'${{ matrix.surface }}'} ref=${'${{ needs.prepare.outputs.deploy_ref }}'}`);

  audit_commit:
    needs: [prepare, dispatch_commit]
    if: ${{ needs.prepare.outputs.approval_mode == 'commit' && needs.prepare.outputs.issue_number != '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Comment on PR (audit trail)
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = Number('${{ needs.prepare.outputs.issue_number }}');
            if (!issueNumber) return;
            const surfaces = JSON.parse('${{ needs.prepare.outputs.surfaces_json }}');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body:
                `Staging promotion approved by @${context.actor}.\n` +
                `- Approval mode: \`commit\`\n` +
                `- Surfaces: \`${surfaces.join(', ')}\`\n` +
                `- Ref: \`${'${{ needs.prepare.outputs.deploy_ref }}'}\``,
            });

  audit_surface:
    needs: [prepare, dispatch_surface]
    if: ${{ needs.prepare.outputs.approval_mode == 'surface' && needs.prepare.outputs.issue_number != '' }}
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Comment on PR (audit trail)
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = Number('${{ needs.prepare.outputs.issue_number }}');
            if (!issueNumber) return;
            const surfaces = JSON.parse('${{ needs.prepare.outputs.surfaces_json }}');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body:
                `Staging promotion approved by @${context.actor}.\n` +
                `- Approval mode: \`surface\`\n` +
                `- Surfaces: \`${surfaces.join(', ')}\`\n` +
                `- Ref: \`${'${{ needs.prepare.outputs.deploy_ref }}'}\``,
            });
